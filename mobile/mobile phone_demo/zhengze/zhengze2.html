<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<input type="text" id="inpt" value="" />
		<button id="btn">提交</button>
		<script src="all_RegExp.js"></script>
	</body>
	
	<script>
		/*
		var pattern = /g.gle/;  //点符号匹配除换行符外的任意字符
		var str = 'g1gle';
		alert(pattern.test(str))
		
		var pattern = /go*gle/;   //o*,表示0个，1个，或者多个o
		var str = "google";
		alert(pattern.test(str));
		
		var pattern = /go+gle/;  //o+ ,表示有1个或者多个o
		var str = 'gooooooooogle';
		alert(pattern.test(str));
		
		var pattern = /go?gle/;  //o? ,表示有0个或者一个o
		var str = 'google';
		alert(pattern.test(str));
		
		var pattern = /g.?gle/;  //.? ,表示有0个或者一个o
		var str = 'ggle';
		alert(pattern.test(str));
		
		var pattern = /go{2,4}gle/;  //o{2,4} 表示匹配o 2-4次，包括2和4 
		var str = 'google';
		alert(pattern.test(str));
		
		var pattern = /go{3}gle/;  //o{3} 表示只能限定为三个
		var str = 'goooogle';
		alert(pattern.test(str));
		
		var pattern = /go{3,}gle/;  //o{3} 表示3个或3个以上
		var str = 'goooogle';
		alert(pattern.test(str));
		
		var pattern = /[a-z]oogle/;  //[a-z]表示26个小写字母任意一个都匹配
		var str = 'zoogle';
		alert(pattern.test(str));
		
		var pattern = /[A-Z]oogle/;  //[A-Z]表示26个大写字母任意一个都匹配
		var str = 'Zoogle';
		alert(pattern.test(str));
		
		var pattern = /[0-9]oogle/;  //[0-9]表示0-9的数字都匹配
		var str = '1oogle';
		alert(pattern.test(str));
		
		var pattern = /[a-zA-Z0-9]oogle/;  // [a-zA-Z0-9]表示匹配大小写的a-zA-Z0-9
		var str = 'oogle';
		alert(pattern.test(str));
		
		var pattern = /[^0-9]oogle/;  // [^0-9]表示非0-9的任意字符
		var str = '0oogle';
		alert(pattern.test(str));
		
		var pattern = /^[0-9]oogle/;  //这个^符号是加在/后面的而不是 []里面的。^符号是强制从字符串第一位开始匹配 
		var str = '4oogle';
		alert(pattern.test(str));
		
		var pattern = /^[0-9]+oogle/;  //这个^符号是加在/后面的而不是 []里面的。^符号是强制从字符串第一位开始匹配 ,+号是匹配一个或者多个
		var str = '4444444oogle';
		alert(pattern.test(str));
		
		var pattern = /\woogle/;  // \w 只匹配字母、数字和下划线[a-zA-Z0-9_]
		var str = '-oogle';
		alert(pattern.test(str));
		
		var pattern = /\Woogle/;  // \W 不匹配字母、数字和下划线[^a-zA-Z0-9_]
		var str = 'oogle';
		alert(pattern.test(str)); 
		
		var pattern = /\doogle/;  // \d 表示[0-9]
		var str = '1oogle';
		alert(pattern.test(str)); 
		
		var pattern = /\Doogle/;  // \D 表示非[0-9]的，[^0-9]
		var str = 'aoogle';
		alert(pattern.test(str)); 
		
		var pattern = /^[a-z]oogle[0-9]+$/;  //^强制首匹配,$强制尾匹配
		var str = 'google555';
		alert(pattern.test(str)); 
		
		var pattern = /goo gle/;  //直接使用空格匹配
		var str = 'goo gle';
		alert(pattern.test(str)); 
		
		var pattern = /goo\sgle/;  // \s表示空格匹配
		var str = 'goo gle';
		alert(pattern.test(str)); 
		
		var pattern = /google\b/;  // \b表示到达边界
		var str = 'google';
		alert(pattern.test(str));
		
		var pattern = /google|baidu|bing/;  // |表示匹配或选择模式
		var str = 'this is a bing ';        //匹配概念，不是相等，包含意思
		alert(pattern.test(str)); 
		
		var pattern = /(google){4,8}$/;  // 分组，可以看成一个字符
		var str = 'google';        		//表示google 4-8次
		alert(pattern.test(str)); 
		
		var pattern = /8(.*)8/;
		var str = 'this is a 8google8';
		alert(pattern.test(str));
		
		var pattern = /8(.*)8/;
		var str = 'this is a 8google8';
		pattern.test(str);
		alert(RegExp.$1)   				//RegExp.$1 表示获取模式中第一个分组对应的匹配字符串
		
		var pattern = /8(.*)8/;
		var str = "This is a 8soso8";
		document.write(str.replace(pattern,'<strong>$1</strong>'))
		// $1表示分组获取字符串匹配到的内容
		
		var pattern = /(.*)\s(.*)/;
		var str = 'google baidu';
		document.write(str.replace(pattern,'$2$1'))  //位置交换
		
		关于贪婪或惰性
		var pattern = /[a-z]+/;			//这里使用了贪婪模式
		var str = 'sdkwkmkwm';
		alert(str.replace(pattern,'1')) //所有的字符变成了1
		
		//关于贪婪或惰性
		var pattern = /[a-z]?/;			//这里使用了惰性模式
		var str = 'sdkwkmkwm';
		alert(str.replace(pattern,'1'))     //只有第一个字符变成了1
		
		//关于贪婪或惰性
		var pattern = /[a-z]?/g;			//开启了全局，并且使用惰性模式
		var str = 'sdkwkmkwm';
		alert(str.replace(pattern,'1'))     //所有字符变成1
		
		//关于贪婪或惰性
		var pattern = /9(.*)9/; 			//使用了贪婪
		var str = "9google9 9google9 9google9";  //匹配到了 google9 9google9 9google
		document.write(str.replace(pattern,"<strong>$1</strong>"));
		//结果：<strong>google</strong><strong>google</strong><strong>google</strong>
		
		//关于贪婪或惰性
		var pattern = /9([^9]*)9/g; 			//另一种惰性，屏蔽了9的匹配，也就是两边的包含字符
		var str = "9google9 9google9 9google9";  
		document.write(str.replace(pattern,"<strong>$1</strong>"));
		//结果正确了：<strong>google</strong><strong>google</strong><strong>google</strong>
		
		//使用exec返回数组
		var pattern = /^[a-z]+\s[0-9]{4}$/;
		var str = 'google 2016';
		alert(pattern.exec(str));  //返回一个包含字符串的数组
		
		//使用exec返回数组
		var pattern = /^[a-z]+/;	//只匹配到字母
		var str = 'google 2016';
		alert(pattern.exec(str));  //返回google的字符串的数组
		
		//使用exec返回数组
		var pattern = /^([a-z]+)\s([0-9]{4})$/;	//使用了分组
		var str = 'google 2016';
		var a = (pattern.exec(str));  
		//alert(a.length); 	//3
		alert(a[0])			//返回匹配到的整个字符串google 2016
		alert(a[1])			//返回匹配到的第一个分组的字符串google
		alert(a[2])			//返回匹配到的第二个分组的字符串2016
		
		//使用exec返回数组
		var pattern = /(\d+)([a-z])/;		//这个叫做捕获性分组，所有的分组都捕获返回
		var str = '123abc';
		alert(pattern.exec(str));
		//a[0]返回123a
		//a[1]返回123
		//a[2]返回a
		
		//使用exec返回数组
		var pattern = /(?:\d+)(?:[a-z])/;		// 非捕获性分组，只要在不需要捕获返回的分组前面加上?:
		var str = '123abc';
		alert(pattern.exec(str));
		
		//使用exec返回数组
		var pattern = /(a?(b?(c?)))/;			//嵌套分组，从外往内获取
		var str = 'abc';
		alert(pattern.exec(str));
		//第一步：a[0]，整个匹配到的字符串
		//第二步：a[1]，匹配第一个分组(a?(b?(c?)))，abc
		//第二步：a[2]，匹配第二个分组(b?(c?))，bc
		//第三步：a[2]，匹配第三个分组(c?)，c
		
		var pattern = /goo(?=gle)/;		//goo后面必须是gle才能返回goo，这里要注意，这里返回的是goo，而不是google
		var str='google';
		alert(pattern.exec(str));		//返回的是goo，而不是google，这是前瞻性捕获
		
		//使用特殊字符匹配
		var pattern = /\[/;		//用\符号来转义正则里的特殊字符，才能匹配
		var str='[';
		alert(pattern.test(str));
		
		var pattern = /^\d+/gm;				//限定了首匹配，并且开启换行模式
		var str = '1、baidu\n2、google\n3、bing';
		alert(str.replace(pattern,'#'));
		*/
		
//		var pattern = /^\d+/gm;				//限定了首匹配，并且开启换行模式
//		var str = '1、baidu\n2、google\n3、bing';
//		alert(str.replace(pattern,'#'));
		
		
	</script>
</html>

